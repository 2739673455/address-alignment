1.功能介绍
    输入一整段收货地址文本，系统自动拆分为出省、市、区/县、街道/乡镇、详细地址、姓名、电话。
    对地址信息进行标准化，得到可直接入库的标准化收货地址信息。
2.实现流程
    1.序列标注
        使用模型进行序列标注。
    2.抽取实体
        用户姓名，电话经过正则表达式校验之后直接填充。
        构造原始地址链路信息（省->市->区->街道->详细地址），除了省市区街道之外的实体统一归类为详细地址。
    3.地址对齐
        缺失补全：对用户输入中缺失的部分信息进行补全
            比如用户只输入了市和区，自动补全省份信息
        错误修正：如果地址链路存在中间错误但两端正确的信息，修正中间的错误地址
            比如用户输入的省和区能匹配，而市不能与省和区匹配上，自动修正市的地址
        剔除无法匹配的信息：对无法与数据库匹配的信息进行剔除
            比如用户输入无法匹配或在现实中不存在的区或街道，将其剔除
    4.封装结果
        将结果封装为JSON回传给前端
3.技术细节
    1.序列标注模型训练
        1.数据预处理
            数据来源与数据清洗：
                开源数据集：清洗过滤，保留符合自身业务规范的数据，统一标签
                业务数据库地址信息表：取出数据脱敏拼接成完整地址信息并添加标注
                AI生成：通过脚本调用大模型批量生成数据，人工抽检确保每批次数据质量
            数据量：共计约20万条样本，按8：1：1划分训练集、验证集、测试集
            标签：包括姓名、电话、省、市、区、街道、详细地址、非实体8类22个标签
        2.模型训练
            1.预训练模型：bert-base-chinese
            2.模型架构：BERT+Dropout+Linear(BertForTokenClassification)
            3.超参数
                最大序列长度：128
                训练轮次：5
                批次大小：256
                学习率：2e-5
                优化器：AdamW
                Dropout概率：0.1
            4.训练策略
                全参数微调
                混合精度训练
                学习率预热：总步数的10%
                学习率衰减：线性衰减，逐渐衰减到0
                早停：连续3轮验证集F1分数不提升则停止
            5.训练环境
                设备：RTX4090单卡(24G显存)，30分钟
        3.模型评估结果
            精确率：95.5%
            召回率：94.5%
            F1分数：95%
    2.地址对齐实现
        1.从标注数据中取出各个实体
        2.使用地址级别序号和实体查询每个层级的所有前缀地址
            比如：省查询出"省"，市查询出该市的"省 市"，区查询出该区的"省 市 区"，街道查询出该街道的"省 市 区 街道"
            同时为了处理标注的时候出现标签错位的问题，会将省，市，区等的地址级别序号互换也加入到查询中
        3.使用字典，将重复的前缀地址合并
            比如：
                {
                    prov1:{
                        city1:{
                            dist1:[road1,road2]
                        city2:...
                    }
                    prov2:...
                    }
                }
        4.将合并后的地址展平成 [省 市 区 街道] 的地址列表，再将其拼接成地址文本字符串
        5.使用地址文本和原始地址文本基于编辑距离计算相似度
            编辑距离是指将字符串A变成字符串B所需要的插入/删除/替换的操作次数
            rapidfuzz.fuzz.ratio():
                sum_len = len(str1) + len(str2)
                distance = sum_len - 2 * longest_common_subsequence
                similarity = (1 - distance / sum_len) * 100
        6.取分数高者作为最终结果
    3.部署与应用
        1.部署方式
            配合发布接口
                使用FastAPI将模型封装为RESTful API
        2.性能指标
            接口的响应延迟（Latency，单个请求处理时间）:100ms
            吞吐量（QPS，每秒成功处理请求数量）:150
            并发能力（Concurrency，能够同时处理的请求数量）:10
        3.监控与维护
            监控线上模型表现
                现象
                    准确率，F1分数随时间推移逐渐下降
                原因
                    观察到出现数据分布漂移
                    统计线上数据的特征分布，与训练集的特征分布进行对比
                    PSI，KL散度，JS散度
            更新迭代模型
                收集最新的线上数据并标注，用新数据结合老数据重新训练模型并进行评估
4.总结
    这个项目实现了将用户输入的收货地址文本信息转换为结构化的数据，并对数据进行标准化处理，使数据符合我们的业务要求。
    项目主要包含序列标注模型和地址标准化两部分。
    首先我们训练了一个地址及用户信息的序列标注模型，基于 bert-base-chinese 预训练模型，采用 BERT+Dropout+Linear 的模型架构。
    模型训练数据来源于开源数据集、业务数据库地址表以及AI生成三部分。
    开源数据集对其进行清洗，过滤出不符合我们业务规范的数据，并对标签进行统一；
    业务数据库的地址表我们将表里每个地址层级的数据取出来拼接成完整地址信息并添加标注作为训练数据的一部分；
    还有一部分数据使用大模型生成，生成一批次的数据之后进行人工抽检，如果抽检没问题就加入训练数据集。
    最终训练数据共20万条，训练集16万、验证集和测试集各2万。
    数据集标签包括姓名、电话、省、市、区、街道、详细地址、非实体8类22个标签。
    准备好数据之后开始训练模型，在 RTX4090 单卡上训练5轮。最终F1分数在96%上下。
    之后将用户姓名记录，电话进行正则校验后记录。
    对地址信息进行标准化，提取出各个地址层级的实体，使用地址层级序号和实体名称作为过滤条件，用 or 拼接到 SQL 查询语句中。
    执行查询语句，查询出所有实体的前缀地址，比如省查询出"省",市查询出该市的"省 市",区查询出该区的"省 市 区"等。
    将查询出的结果使用字典构建层级关系，同时合并相同实体。
    再将字典中的数据展平，返回层级完整的一条或多条地址信息。
    使用从数据库中查询出来的候选地址信息与用户输入的地址信息进行文本相似度计算，基于编辑距离计算文本相似度。
    取最相似的一条数据作为最终结果，将其记录。
    最终将所有结果以JSON格式返回前端。